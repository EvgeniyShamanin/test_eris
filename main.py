'''
Написать функцию, строящую дерево по списку пар id (id родителя, id потомка),
где None - id корневого узла.
'''

source = [
    (None, 'a'),
    (None, 'b'),
    (None, 'c'),
    ('a', 'a1'),
    ('a', 'a2'),
    ('a2', 'a21'),
    ('a2', 'a22'),
    ('b', 'b1'),
    ('b1', 'b11'),
    ('b11', 'b111'),
    ('b', 'b2'),
    ('c', 'c1'),
]

expected = {
    'a': {'a1': {}, 'a2': {'a21': {}, 'a22': {}}},
    'b': {'b1': {'b11': {'b111': {}}}, 'b2': {}},
    'c': {'c1': {}},
}


# использовал рекурсию
def to_tree(array, my_dict={}):
    # проверка на выход из рекурсии
    if len(array) == 0:
        return my_dict
    else:
        """
        посмотрел что список на дали уже отсортированный поэтому не сортировал, начал с конца списа
        с "листьев" срезал по последнему элементу списка и добавлял в словарь
        """
        item = array.pop()
        # если коренной элемент то ничего делать не нужно так как этот узел уже есть
        if item[0] is None:
            return to_tree(array, my_dict)
        else:
            # проверяем присутствует ли первый элемент в списке
            if item[0] in my_dict:
                # если присутствует то проверяем а присутствует ли второй элемент
                if item[1] in my_dict:
                    # если второй присутствует то срезаем этот узел
                    second_el = my_dict.pop(item[1])
                    # добавляем его в новый узел
                    new_dic = {item[1]: second_el}
                    # обновляем первый элемент
                    my_dict[item[0]].update(new_dic)
                    # возвращаемся в начало функции и начинаем проверять следующий элемент списка
                    return to_tree(array, my_dict)
                # если второго элемента в словаре нет
                else:
                    # создаем новый лист
                    new_dic = {item[1]: {}}
                    # обновляем узел
                    my_dict[item[0]].update(new_dic)
                    # возвращаемся в начало функции и начинаем проверять следующий элемент списка
                    return to_tree(array, my_dict)
            # проверяем если не присутствует первый элемент то присутствует ли второй элемент в словаре
            elif item[1] in my_dict:
                # если присутствует то вырезаем его
                old_el = my_dict.pop(item[1])
                # добавляем новый узел
                new_dic = {item[0]: {item[1]: old_el}}
                # обновляем словарь
                my_dict.update(new_dic)
                # возвращаемся в начало функции и начинаем проверять следующий элемент списка
                return to_tree(array, my_dict)
            # если ни каких элементов в словаре нет
            else:
                # создаем узел с листом
                new_dic = {item[0]: {item[1]: {}}}
                # обновляем словарь
                my_dict.update(new_dic)
                # возвращаемся в начало функции и начинаем проверять следующий элемент списка
                return to_tree(array, my_dict)


print(to_tree(source))

# словарь получился немного не по порядку, но проверка прошла ошибки нет.
# попробовал добавить элементы в список все работает.
assert to_tree(source) == expected